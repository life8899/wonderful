/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:88: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:125: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:162: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:250: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f1_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1245: warning: Matches are not exhaustive. Found near fn [th1, th2] => ACL_CONJ th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1276: warning: Matches are not exhaustive. Found near fn [th] => ACL_DISJ1 disj2 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1304: warning: Matches are not exhaustive. Found near fn [th] => ACL_DISJ2 disj1 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1336: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1337: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1340: warning: Matches are not exhaustive. Found near fn [th] => ACL_MP th2 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1374: warning: Matches are not exhaustive. Found near fn [th] => AND_SAYS_RL th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1408: warning: Matches are not exhaustive. Found near fn [th] => AND_SAYS_LR th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1440: warning: Matches are not exhaustive. Found near fn [th1, th2] => CONTROLS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1473: warning: Matches are not exhaustive. Found near fn [th1, th2] => DC th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1506: warning: Matches are not exhaustive. Found near fn [th1, th2] => DOMI_TRANS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1541: warning: Matches are not exhaustive. Found near fn [th1, th2] => DOMS_TRANS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1575: warning: Matches are not exhaustive. Found near fn [th1, th2] => HS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1601: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1602: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1604: warning: Pattern is not exhaustive.
Found near val (_, [proptype, ...]) = dest_type formType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1643: warning: Matches are not exhaustive.
Found near fn [th1, th2, th3] => IL_DOMI th2 th1 th3
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1679: warning: Matches are not exhaustive.
Found near fn [th1, th2] => MONO_SPEAKS_FOR th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1709: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1710: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1745: warning: Matches are not exhaustive. Found near fn [th] => QUOTING_LR th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1776: warning: Matches are not exhaustive. Found near fn [th] => QUOTING_RL th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1810: warning: Matches are not exhaustive. Found near fn [th1, th2, th3] => REPS th1 th2 th3
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1842: warning: Matches are not exhaustive. Found near fn [th1, th2] => REP_SAYS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1869: warning: Matches are not exhaustive. Found near fn [th] => SAYS princ th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1901: warning: Matches are not exhaustive. Found near fn [th1, th2] => SPEAKS_FOR th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1934: warning: Matches are not exhaustive.
Found near fn [th1, th2] => TRANS_SPEAKS_FOR th1 th2
<<HOL message: Created theory "example1">>
Saved theorem _____ "num2commands_commands2num"
Saved theorem _____ "commands2num_num2commands"
Saved theorem _____ "num2commands_11"
Saved theorem _____ "commands2num_11"
Saved theorem _____ "num2commands_ONTO"
Saved theorem _____ "commands2num_ONTO"
Saved theorem _____ "num2commands_thm"
Saved theorem _____ "commands2num_thm"
Saved theorem _____ "commands_EQ_commands"
Saved theorem _____ "commands_case_def"
Saved theorem _____ "datatype_commands"
Saved theorem _____ "commands_distinct"
Saved theorem _____ "commands_case_cong"
Saved theorem _____ "commands_nchotomy"
Saved theorem _____ "commands_Axiom"
Saved theorem _____ "commands_induction"
<<HOL message: Defined type: "commands">>
Saved theorem _____ "num2staff_staff2num"
Saved theorem _____ "staff2num_num2staff"
Saved theorem _____ "num2staff_11"
Saved theorem _____ "staff2num_11"
Saved theorem _____ "num2staff_ONTO"
Saved theorem _____ "staff2num_ONTO"
Saved theorem _____ "num2staff_thm"
Saved theorem _____ "staff2num_thm"
Saved theorem _____ "staff_EQ_staff"
Saved theorem _____ "staff_case_def"
Saved theorem _____ "datatype_staff"
Saved theorem _____ "staff_distinct"
Saved theorem _____ "staff_case_cong"
Saved theorem _____ "staff_nchotomy"
Saved theorem _____ "staff_Axiom"
Saved theorem _____ "staff_induction"
<<HOL message: Defined type: "staff">>
Saved theorem _____ "aclExerciseOne"
Saved theorem _____ "aclExerciseOneA"
Saved theorem _____ "aclExerciseTwoB"
Saved theorem _____ "aclExerciseTwo"
Saved theorem _____ "aclExerciseTwoA"
Theory: example1

Parents:
    aclDrules

Type constants:
    commands 0
    staff 0

Term constants:
    Alice           :staff
    Bob             :staff
    Carol           :staff
    Dan             :staff
    abort           :commands
    commands2num    :commands -> num
    commands_CASE   :commands -> α -> α -> α -> α -> α
    commands_size   :commands -> num
    go              :commands
    launch          :commands
    nogo            :commands
    num2commands    :num -> commands
    num2staff       :num -> staff
    staff2num       :staff -> num
    staff_CASE      :staff -> α -> α -> α -> α -> α
    staff_size      :staff -> num

Definitions:
    @tempAlice_def
      |- Alice = num2staff 0
    @tempBob_def
      |- Bob = num2staff 1
    @tempCarol_def
      |- Carol = num2staff 2
    @tempDan_def
      |- Dan = num2staff 3
    @tempabort_def
      |- abort = num2commands 3
    @tempgo_def
      |- go = num2commands 0
    @templaunch_def
      |- launch = num2commands 2
    @tempnogo_def
      |- nogo = num2commands 1
    commands_BIJ
      |- (∀a. num2commands (commands2num a) = a) ∧
         ∀r. (λn. n < 4) r ⇔ (commands2num (num2commands r) = r)
    commands_CASE
      |- ∀x v0 v1 v2 v3.
           (case x of
              go => v0
            | nogo => v1
            | launch => v2
            | abort => v3) =
           (λm.
              if m < 1 then v0
              else if m < 2 then v1
              else if m = 2 then v2
              else v3) (commands2num x)
    commands_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 4) rep
    commands_size_def
      |- ∀x. commands_size x = 0
    staff_BIJ
      |- (∀a. num2staff (staff2num a) = a) ∧
         ∀r. (λn. n < 4) r ⇔ (staff2num (num2staff r) = r)
    staff_CASE
      |- ∀x v0 v1 v2 v3.
           (case x of
              Alice => v0
            | Bob => v1
            | Carol => v2
            | Dan => v3) =
           (λm.
              if m < 1 then v0
              else if m < 2 then v1
              else if m = 2 then v2
              else v3) (staff2num x)
    staff_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 4) rep
    staff_size_def
      |- ∀x. staff_size x = 0

Theorems:
    aclExerciseOne
      |- (M,Oi,Os) sat Name Alice says prop go ⇒
         (M,Oi,Os) sat Name Bob says prop go ⇒
         (M,Oi,Os) sat Name Alice meet Name Bob says prop go
    aclExerciseOneA
      |- (M,Oi,Os) sat Name Alice says prop go ⇒
         (M,Oi,Os) sat Name Bob says prop go ⇒
         (M,Oi,Os) sat Name Alice meet Name Bob says prop go
    aclExerciseTwo
       [...] |- (M,Oi,Os) sat Name Bob says prop launch
    aclExerciseTwoA
      |- (M,Oi,Os) sat Name Alice says prop go ⇒
         (M,Oi,Os) sat Name Alice controls prop go ⇒
         (M,Oi,Os) sat prop go impf prop launch ⇒
         (M,Oi,Os) sat Name Bob says prop launch
    aclExerciseTwoB
      |- (M,Oi,Os) sat Name Alice says prop go ⇒
         (M,Oi,Os) sat Name Bob says prop go ⇒
         (M,Oi,Os) sat Name Alice meet Name Bob says prop go
    commands2num_11
      |- ∀a a'. (commands2num a = commands2num a') ⇔ (a = a')
    commands2num_ONTO
      |- ∀r. r < 4 ⇔ ∃a. r = commands2num a
    commands2num_num2commands
      |- ∀r. r < 4 ⇔ (commands2num (num2commands r) = r)
    commands2num_thm
      |- (commands2num go = 0) ∧ (commands2num nogo = 1) ∧
         (commands2num launch = 2) ∧ (commands2num abort = 3)
    commands_Axiom
      |- ∀x0 x1 x2 x3.
           ∃f.
             (f go = x0) ∧ (f nogo = x1) ∧ (f launch = x2) ∧
             (f abort = x3)
    commands_EQ_commands
      |- ∀a a'. (a = a') ⇔ (commands2num a = commands2num a')
    commands_case_cong
      |- ∀M M' v0 v1 v2 v3.
           (M = M') ∧ ((M' = go) ⇒ (v0 = v0')) ∧
           ((M' = nogo) ⇒ (v1 = v1')) ∧ ((M' = launch) ⇒ (v2 = v2')) ∧
           ((M' = abort) ⇒ (v3 = v3')) ⇒
           ((case M of
               go => v0
             | nogo => v1
             | launch => v2
             | abort => v3) =
            case M' of
              go => v0'
            | nogo => v1'
            | launch => v2'
            | abort => v3')
    commands_case_def
      |- (∀v0 v1 v2 v3.
            (case go of
               go => v0
             | nogo => v1
             | launch => v2
             | abort => v3) =
            v0) ∧
         (∀v0 v1 v2 v3.
            (case nogo of
               go => v0
             | nogo => v1
             | launch => v2
             | abort => v3) =
            v1) ∧
         (∀v0 v1 v2 v3.
            (case launch of
               go => v0
             | nogo => v1
             | launch => v2
             | abort => v3) =
            v2) ∧
         ∀v0 v1 v2 v3.
           (case abort of
              go => v0
            | nogo => v1
            | launch => v2
            | abort => v3) =
           v3
    commands_distinct
      |- go ≠ nogo ∧ go ≠ launch ∧ go ≠ abort ∧ nogo ≠ launch ∧
         nogo ≠ abort ∧ launch ≠ abort
    commands_induction
      |- ∀P. P abort ∧ P go ∧ P launch ∧ P nogo ⇒ ∀a. P a
    commands_nchotomy
      |- ∀a. (a = go) ∨ (a = nogo) ∨ (a = launch) ∨ (a = abort)
    datatype_commands
      |- DATATYPE (commands go nogo launch abort)
    datatype_staff
      |- DATATYPE (staff Alice Bob Carol Dan)
    num2commands_11
      |- ∀r r'.
           r < 4 ⇒
           r' < 4 ⇒
           ((num2commands r = num2commands r') ⇔ (r = r'))
    num2commands_ONTO
      |- ∀a. ∃r. (a = num2commands r) ∧ r < 4
    num2commands_commands2num
      |- ∀a. num2commands (commands2num a) = a
    num2commands_thm
      |- (num2commands 0 = go) ∧ (num2commands 1 = nogo) ∧
         (num2commands 2 = launch) ∧ (num2commands 3 = abort)
    num2staff_11
      |- ∀r r'.
           r < 4 ⇒ r' < 4 ⇒ ((num2staff r = num2staff r') ⇔ (r = r'))
    num2staff_ONTO
      |- ∀a. ∃r. (a = num2staff r) ∧ r < 4
    num2staff_staff2num
      |- ∀a. num2staff (staff2num a) = a
    num2staff_thm
      |- (num2staff 0 = Alice) ∧ (num2staff 1 = Bob) ∧
         (num2staff 2 = Carol) ∧ (num2staff 3 = Dan)
    staff2num_11
      |- ∀a a'. (staff2num a = staff2num a') ⇔ (a = a')
    staff2num_ONTO
      |- ∀r. r < 4 ⇔ ∃a. r = staff2num a
    staff2num_num2staff
      |- ∀r. r < 4 ⇔ (staff2num (num2staff r) = r)
    staff2num_thm
      |- (staff2num Alice = 0) ∧ (staff2num Bob = 1) ∧
         (staff2num Carol = 2) ∧ (staff2num Dan = 3)
    staff_Axiom
      |- ∀x0 x1 x2 x3.
           ∃f.
             (f Alice = x0) ∧ (f Bob = x1) ∧ (f Carol = x2) ∧
             (f Dan = x3)
    staff_EQ_staff
      |- ∀a a'. (a = a') ⇔ (staff2num a = staff2num a')
    staff_case_cong
      |- ∀M M' v0 v1 v2 v3.
           (M = M') ∧ ((M' = Alice) ⇒ (v0 = v0')) ∧
           ((M' = Bob) ⇒ (v1 = v1')) ∧ ((M' = Carol) ⇒ (v2 = v2')) ∧
           ((M' = Dan) ⇒ (v3 = v3')) ⇒
           ((case M of
               Alice => v0
             | Bob => v1
             | Carol => v2
             | Dan => v3) =
            case M' of
              Alice => v0'
            | Bob => v1'
            | Carol => v2'
            | Dan => v3')
    staff_case_def
      |- (∀v0 v1 v2 v3.
            (case Alice of
               Alice => v0
             | Bob => v1
             | Carol => v2
             | Dan => v3) =
            v0) ∧
         (∀v0 v1 v2 v3.
            (case Bob of
               Alice => v0
             | Bob => v1
             | Carol => v2
             | Dan => v3) =
            v1) ∧
         (∀v0 v1 v2 v3.
            (case Carol of
               Alice => v0
             | Bob => v1
             | Carol => v2
             | Dan => v3) =
            v2) ∧
         ∀v0 v1 v2 v3.
           (case Dan of
              Alice => v0
            | Bob => v1
            | Carol => v2
            | Dan => v3) =
           v3
    staff_distinct
      |- Alice ≠ Bob ∧ Alice ≠ Carol ∧ Alice ≠ Dan ∧ Bob ≠ Carol ∧
         Bob ≠ Dan ∧ Carol ≠ Dan
    staff_induction
      |- ∀P. P Alice ∧ P Bob ∧ P Carol ∧ P Dan ⇒ ∀a. P a
    staff_nchotomy
      |- ∀a. (a = Alice) ∨ (a = Bob) ∨ (a = Carol) ∨ (a = Dan)
Exporting theory "example1" ... done.
Theory "example1" took 0.25200s to build
Completed load of example1Script
